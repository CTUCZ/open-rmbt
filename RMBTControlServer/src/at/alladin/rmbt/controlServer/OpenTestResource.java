/*******************************************************************************
 * Copyright 2013 alladin-IT OG
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package at.alladin.rmbt.controlServer;

import at.alladin.rmbt.shared.Classification;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.restlet.resource.Get;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Arrays;
import java.util.HashSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.restlet.data.Status;

public class OpenTestResource extends ServerResource
{
    //maximum of rows sent in one single request
    public final int MAXROWS = 400;
    
    //all fields that should be displayed in a detailed request
    private final String[] openDataFieldsFull = {"open_uuid", "open_test_uuid", "time", "cat_technology", "network_type", "lat", "long", "loc_src", "zip_code",
        "download_kbit", "upload_kbit", "ping_ms", "signal_strength", "server_name", "test_duration", "num_threads", "platform", "model", "client_version",
        "network_mcc_mnc", "network_name", "provider_name", "sim_mcc_mnc", "connection", "asn", "ip_anonym", "ndt_download_kbit", "ndt_upload_kbit"};
    
    //all fields that should be displayed in a general request (e.g. all tests for one user)
    private final String[] openDataFieldsSummary = {"open_uuid", "open_test_uuid", "time", "lat", "long", "download_kbit", "upload_kbit", 
        "ping_ms", "signal_strength",  "platform"};
    
    //all fields that are numbers (and are formatted as numbers in json)
    private final HashSet<String> openDataNumberFields = new HashSet<String>(Arrays.asList(new String[]{"time", "lat", "long", "zip_code", "download_kbit",
        "upload_kbit","ping_ms","signal_strength","test_duration","num_threads","ndt_download_kbit","ndt_upload_kbit","asn"}));
    
    @Get("json")
    public String request(final String entity)
    {
        addAllowOrigin();

        //routing should be in a way in which open_test_uuid is always set
        String openUUID = getRequest().getAttributes().get("open_test_uuid").toString();
        return getSingleOpenTest(openUUID);
        
    }
    
    /**
     * Gets the JSON-Representation of all open-data-fields for one specific
     * open-test-uuid
     * @param openTestUUID
     * @return the json-string
     */
    private String getSingleOpenTest(String openTestUUID) {       
        final String sql = "SELECT t.uid as test_uid, " +
                " ('P' || t.open_uuid) open_uuid," +
                " ('O' || t.open_test_uuid) open_test_uuid," + 
                " to_char(t.time AT TIME ZONE 'UTC', 'YYYY-MM-DD HH24:MI') \"time\"," +
                " nt.group_name cat_technology," +
                " nt.name network_type," +
                " t.geo_lat lat," +
                " t.geo_long long," +
                " t.geo_provider loc_src," +
                " t.zip_code," +
                " t.speed_download download_kbit," +
                " t.speed_upload upload_kbit," +
                " (t.ping_shortest::float / 1000000) ping_ms," +
                " t.signal_strength," +
                " ts.name server_name," +
                " duration test_duration," +
                " num_threads," +
                " plattform as platform," +
                " COALESCE(adm.fullname, t.model) model," +
                " client_software_version client_version," +
                " network_operator network_mcc_mnc," +
                " network_operator_name network_name," +
                " network_sim_operator sim_mcc_mnc," +
                " network_sim_country sim_mcc_country," +
                " COALESCE(prov.name, mprov.name) provider_name," +
                " nat_type \"connection\"," +
                " public_ip_asn asn," +
                " client_public_ip_anonymized ip_anonym," +
                " (ndt.s2cspd*1000)::int ndt_download_kbit," +
                " (ndt.c2sspd*1000)::int ndt_upload_kbit" +
                " FROM test t" +
                " LEFT JOIN network_type nt ON nt.uid=t.network_type" +
                " LEFT JOIN android_device_map adm ON adm.codename=t.model" +
                " LEFT JOIN test_server ts ON ts.uid=t.server_id" +
                " LEFT JOIN test_ndt ndt ON t.uid=ndt.test_id" +
                " LEFT JOIN provider prov ON t.provider_id=prov.uid" +
                " LEFT JOIN provider mprov ON t.mobile_provider_id=mprov.uid" +
                " WHERE " +
                " t.deleted = false" +
                " AND time > '2012-12-22 01:00'" +
                " AND status = 'FINISHED' " +
                " AND t.open_test_uuid = ? ";
        
        final String[] columns;
        PreparedStatement ps = null;
        ResultSet rs = null;
        final JSONObject response = new JSONObject();
        try
        {
            ps = conn.prepareStatement(sql);
            
            //openTestIDs are starting with "O"
            if (openTestUUID != null && openTestUUID.startsWith("O")) {
                openTestUUID = openTestUUID.substring(1);
            }
            ps.setObject(1, openTestUUID,Types.OTHER);
            
            if (!ps.execute())
                return null;
            rs = ps.getResultSet();
            
            
            if (rs.next())
            {
                //fetch data for every field
                for (int i=0;i<openDataFieldsFull.length;i++) {
                    
                    //convert data to correct json response
                    final Object obj = rs.getObject(openDataFieldsFull[i]);
                    if (obj==null) {
                        response.put(openDataFieldsFull[i], JSONObject.NULL);
                    } else if (openDataNumberFields.contains(openDataFieldsFull[i])) {
                        response.put(openDataFieldsFull[i], JSONObject.stringToValue(obj.toString()));
                    } else {
                        response.put(openDataFieldsFull[i], obj.toString());
                    }
                    
                }
                
                
                //also, classify download, upload, ping, signal
                response.put("download_classification", Classification.classify(Classification.THRESHOLD_DOWNLOAD, rs.getLong("download_kbit")));
                response.put("upload_classification", Classification.classify(Classification.THRESHOLD_UPLOAD, rs.getLong("upload_kbit")));
                response.put("ping_classification", Classification.classify(Classification.THRESHOLD_DOWNLOAD, rs.getLong("ping_ms")*1000000));
                //classify signal accordingly
                if (rs.getString("signal_strength") != null) {
                    if (rs.getString("network_type").equals("WLAN")) {
                        response.put("signal_classification", Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, rs.getLong("signal_strength")));
                    } else {
                        response.put("signal_classification", Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, rs.getLong("signal_strength")));
                    }
                } else {
                    response.put("signal_classification", JSONObject.NULL);
                }
                
                
                //also load download/upload-speed-data if possible
                JSONObject speedCurve = new JSONObject();
                JSONArray downloadSpeeds = new JSONArray();
                JSONArray uploadSpeeds = new JSONArray();
                
                //Load speed data from database
                PreparedStatement psSpeed = conn.prepareStatement("SELECT upload, thread, bytes, (time::float /1000/1000) as time FROM test_speed WHERE test_id = ? ORDER BY upload, time ASC");
                psSpeed.setLong(1,rs.getLong("test_uid"));
                
                //Prepare arrays (bytes cumulated per thread)
                long bytes[] = new long[rs.getInt("num_threads")];
                ResultSet rsSpeed = psSpeed.executeQuery();                
                long bytesCum=0;
                boolean upload = false;
                while(rsSpeed.next()) {
                    int thread = rsSpeed.getInt("thread");
                    double ms = rsSpeed.getDouble("time");
                    
                    //if its the first time a upload => clear array
                    if (!upload && rsSpeed.getBoolean("upload")) {
                        for (int i=0;i<bytes.length;i++)
                        {
                            bytes[i]=0;
                        }
                        bytesCum=0;
                        upload=true;
                    }
                    
                    //bytesCum = bytesCum - old + new
                    bytesCum = bytesCum - bytes[thread];
                    bytes[thread] = rsSpeed.getLong("bytes");
                    bytesCum = bytesCum + bytes[thread];
                    
                    //put the object in the json-response
                    JSONArray json = (rsSpeed.getBoolean("upload"))?uploadSpeeds:downloadSpeeds;
                    JSONObject obj = new JSONObject();
                    obj.put("time_elapsed", (int) ms);
                    obj.put("bytes_total",bytesCum);
                    json.put(obj);
                }
                
                
                speedCurve.put("upload", uploadSpeeds);
                speedCurve.put("download", downloadSpeeds);
                response.put("speed_curve", speedCurve);
                
            } else {
                //invalid open_uuid
                setStatus(Status.CLIENT_ERROR_NOT_FOUND);
                response.put("error","invalid open-uuid");
            }
        }
        catch (final JSONException e) {
            Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
        } catch (SQLException ex) {
            try {
                setStatus(Status.CLIENT_ERROR_NOT_FOUND);
                response.put("error","invalid open-uuid");
            } catch (JSONException ex1) {
                Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, ex1);
            }
            Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, ex);
        }
        finally
        {
            try
            {
                if (rs != null)
                    rs.close();
                if (ps != null)
                    ps.close();
            }
            catch (final SQLException e)
            {
                Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
            }
        }

        return response.toString();
    }
        
    
}
